# Задание 1:
Написать парсер для получения строк данных, по какому-либо запросу (или атрибуту, к примеру, вывести данные из базы по стране Россия) с использованием технологии Linq.
Требования:
1)	Класс, который занимается чтением данных, должен быть унаследован от интерфейса IEnumerable. 
2)	Считанные данные должны быть структурированы и иметь класс, описывающий их модель.
3)	Для получения данных, должен использоваться один или несколько методов расширения Linq. Пример запроса citiesSource.Where(x => x.Name.Lenght > 5). 
4)	Создать и продемонстрировать форматированный, по своему усмотрению, вывод в консоли (или на форме) с перечислением важных (координатами можно пренебречь) атрибутов запрашиваемого поиска.
5)	Использовать любой источник данных с информацией о городах или использовать приложенный файл geo.csv
6)	Соблюдать принципы ООП.
Примечание:
1.	Если по каким-либо причинам, данные читаются некорректно, попробуйте изменить кодировку исходного текста на utf-8. На примере Notepad++, «Кодировки»-«Преобразовать в UTF-8». Или изменить кодировку чтения и вывода в самой студии.
2.	Использование конструкции yield return <data> позволяет возвращаться к месту, ранее на котором происходил вывод, при повторном вызове метода.

# Задание 2:
Ответить письменно на вопрос «Что выведет следующий код? Почему?»:
var list = new List<string> { "Foo", "Bar", "Baz", "FoB" };
var startLetter = "F";
var query = list.Where(c => c.Contains(startLetter));
startLetter = "B";
query = query.Where(c => c.StartsWith(startLetter));
Console.WriteLine(query.Count());

Ответ: 2.
1. 1 присваивание query передает не коллекцию или перечисление, а отложенный запрос, который не имеет результата, а лишь содержит инструкцию, которая будет реализована при перечислении элементов query.
2. 2 присваивание query происходит вызовом Where у отложенного запроса. Результата нет, по этому в метод передается объект query._source, который был присвоен в конструкторе WhereListItertor (а именно это и является ранее называемым отложенным запросом).